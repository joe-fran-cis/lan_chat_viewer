<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LAN Chat — Viewer (Full History)</title>

    <style>
        body {
            font-family: Segoe UI, Roboto, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #09121a;
            color: #e6eef6;
        }

        #header {
            padding: 10px;
            background: #0f2630;
            color: #6fd6ff;
            text-align: center;
            font-weight: 600;
        }

        #status {
            padding: 12px;
            text-align: center;
            color: #bcd;
            min-height: 44px;
        }

        #chat-window {
            flex: 1;
            overflow: auto;
            padding: 12px;
        }

        .message-container {
            margin-bottom: 10px;
            display: flex;
        }

        .my-message {
            justify-content: flex-end;
        }

        .other-message {
            justify-content: flex-start;
        }

        .bubble {
            /* Compactness: Reduced max-width for desktop view */
            max-width: 30%;
            padding: 10px 14px;
            border-radius: 18px;

            /* --- Wrapping Fix --- */
            /* Ensure words break aggressively for long URLs/strings */
            word-wrap: break-word;
            overflow-wrap: break-word;
            /* This is the key fix to break long strings at any character if needed */
            word-break: break-all;

            font-size: 0.95em;
            line-height: 1.4;
            position: relative;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            text-align: left;
            /* Default: Mob/My Message (Blue/Cyan gradient) */
            background: linear-gradient(to right, #00f2fe, #4facfe);
            color: #000;
        }

        .other-message .bubble {
            /* PC/Other Message (Darker blue gradient) */
            background: linear-gradient(to right, #005691, #003050);
            color: white;
        }

        /* Style for links inside the bubble */
        .bubble a {
            color: inherit;
            text-decoration: underline;
        }

        .ts {
            display: block;
            margin-top: 6px;
            font-size: 0.75em;
            opacity: .8;
            text-align: right;
        }

        /* WhatsApp DATE style */
        .date-sep {
            display: inline-block;
            margin: 15px auto;
            padding: 6px 14px;
            background: #262d33;
            color: #cfd3d7;
            font-size: 0.78em;
            border-radius: 12px;
            text-align: center;
        }

        #controls {
            padding: 8px;
            background: #07121a;
            border-top: 1px solid #0f2736;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 0;
            background: #1976d2;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #1565c0;
        }

        @media (max-width: 600px) {
            .bubble {
                /* Compactness: Reduced max-width for mobile view */
                max-width: 85%;
            }
        }
    </style>
</head>

<body>
    <!-- Hidden status element, as its logging is commented out -->
    <div id="status" style="display:none;"></div>

    <div id="chat-window"></div>

    <div id="controls">
        <button id="refresh">Refresh</button>
        <div id="last-sync" style="font-size: 0.9em; color:#9ab;">Last sync: —</div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBIUJAvCsMYeG38Sd2fRBR9ABT8X8NpQrY",
            authDomain: "lan-chat-f7896.firebaseapp.com",
            databaseURL: "https://lan-chat-f7896-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "lan-chat-f7896",
            storageBucket: "lan-chat-f7896.firebasestorage.app",
            messagingSenderId: "662426073276",
            appId: "1:662426073276:web:7c4dc65b2ef346a05278b9"
        };

        const statusEl = document.getElementById("status");
        const chatWindow = document.getElementById("chat-window");
        const lastSyncEl = document.getElementById("last-sync");
        const refreshBtn = document.getElementById("refresh");

        function escapeHtml(t) {
            return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        // Converts text containing URLs into HTML with clickable links
        function linkify(text) {
            const urlRegex = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[\S]+(\b|$))|(\b[\w]+(\.[\w]{2,}){1,3}\b)/gim;

            const escapedText = escapeHtml(text);

            const linkedText = escapedText.replace(urlRegex, (url) => {
                let href = url;
                if (!url.match(/^(https?|ftp):\/\//i) && url.indexOf('.') > -1) {
                    href = 'http://' + url;
                }
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });

            return linkedText;
        }

        /**
         * Converts a Firebase object map (which might contain message objects and a metadata string)
         * into a clean array of message objects, filtering out non-object values like 'uploadedAt'.
         * This function is primarily for the old data structure (multi-message per node).
         */
        function normalizeToArray(obj) {
            if (!obj || typeof obj !== 'object') return [];

            // 1. Get all values from the object 
            const values = Object.values(obj);

            // 2. Filter: Only keep items that are objects AND have a 'message' or 'msg' field.
            return values.filter(item => {
                // Check if item is a non-null object
                const isObject = typeof item === 'object' && item !== null;
                // Check if it has the required message fields
                const isMessage = isObject && (item.message || item.msg);
                return isMessage;
            });
        }

        function formatDateForDisplay(dateStr) {
            const d = new Date(dateStr);
            if (isNaN(d)) return dateStr;

            const today = new Date();
            const yest = new Date();
            yest.setDate(today.getDate() - 1);

            const sameDay = (a, b) => a.toDateString() === b.toDateString();

            if (sameDay(d, today)) return "Today";
            if (sameDay(d, yest)) return "Yesterday";

            // Format as "21 Nov 2025"
            return d.toLocaleDateString("en-US", {
                day: "2-digit",
                month: "short",
                year: "numeric"
            });
        }

        function renderDateSeparator(dateString) {
            const wrap = document.createElement("div");
            wrap.style.display = "flex";
            wrap.style.justifyContent = "center";

            const sep = document.createElement("div");
            sep.className = "date-sep";
            sep.textContent = formatDateForDisplay(dateString);

            wrap.appendChild(sep);
            chatWindow.appendChild(wrap);
        }

        function renderMessage(msg) {
            // Note: Messages from Mob are typically the mobile sender, so we treat them as 'my-message' for color distinction.
            const isMyMessage = msg.source === "Mob";
            const container = document.createElement("div");
            container.className =
                "message-container " + (isMyMessage ? "my-message" : "other-message");

            const bubble = document.createElement("div");
            bubble.className = "bubble";

            const text = msg.message ?? msg.msg ?? "";
            const time = msg.time ?? "";

            const linkedText = linkify(text);

            bubble.innerHTML =
                linkedText + `<span class="ts">${escapeHtml(time)}</span>`;

            container.appendChild(bubble);
            chatWindow.appendChild(container);
        }

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        async function loadLatest() {
            console.log("Starting full history data load...");
            chatWindow.innerHTML = "";
            let allMessages = [];

            // --- Querying ALL log entries ---
            const snap = await db.ref("/chat_logs").once("value");

            // Capture the exact moment the data retrieval completes locally
            const syncDate = new Date();

            if (!snap.exists()) {
                lastSyncEl.textContent = "Last sync: No chat logs found";
                return;
            }

            // Iterate through every single log node
            snap.forEach(childSnapshot => {
                const nodeData = childSnapshot.val();

                // Step 1: Unwrap 'data' if present (for backward compatibility)
                const messageBlock = nodeData.data ?? nodeData;

                let messagesFromNode = [];

                // Step 2: Check if the block is a single message object (new format)
                if (messageBlock && (messageBlock.message || messageBlock.msg)) {
                    // It's a single message object, so we wrap it in an array.
                    messagesFromNode = [messageBlock];
                } else {
                    // The data is a map of messages (old format), use normalizeToArray.
                    messagesFromNode = normalizeToArray(messageBlock);
                }

                // Add the messages from this node to the master list
                allMessages = allMessages.concat(messagesFromNode);
            });

            console.log(`Total messages found across all logs: ${allMessages.length}`);

            if (allMessages.length === 0) {
                // Custom format creation for timestamp when no messages are found
                const datePart = syncDate.toLocaleDateString("en-US", {
                    day: '2-digit', month: 'short', year: 'numeric'
                });
                const timePart = syncDate.toLocaleTimeString("en-US", {
                    hour: '2-digit', minute: '2-digit', hour12: false
                });
                const readableTime = `${datePart.replace(',', '')}, ${timePart}`;

                lastSyncEl.textContent = `Last sync: ${readableTime} (No messages parsed)`;
                return;
            }

            // --- Rendering Logic ---

            // Sort ALL messages chronologically based on internal date/time fields
            allMessages.sort((a, b) => {
                const da = new Date(`${a.date} ${a.time}`);
                const db = new Date(`${b.date} ${b.time}`);
                // Fallback for invalid dates
                if (isNaN(da) || isNaN(db)) return 0;
                return da - db;
            });

            let prevDate = "";

            // Render all messages
            allMessages.forEach(msg => {
                // Ensure date exists and handle date separators
                if (msg.date && msg.date !== prevDate) {
                    renderDateSeparator(msg.date);
                    prevDate = msg.date;
                }
                renderMessage(msg);
            });

            // Scroll to the latest message
            chatWindow.scrollTop = chatWindow.scrollHeight;

            // --- Update sync timestamp ---

            // Custom format creation: "17 Nov 2025, 22:59"
            const datePart = syncDate.toLocaleDateString("en-US", {
                day: '2-digit', month: 'short', year: 'numeric'
            });
            const timePart = syncDate.toLocaleTimeString("en-US", {
                hour: '2-digit', minute: '2-digit', hour12: false
            });

            const readableTime = `${datePart.replace(',', '')}, ${timePart}`;

            lastSyncEl.textContent =
                `Last sync: ${readableTime}`;
        }

        refreshBtn.addEventListener("click", loadLatest);
        loadLatest();
    </script>

</body>

</html>